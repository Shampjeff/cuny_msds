---
title: "Project 1 Chess Table"
author: "Jeff Shamp"
date: "2/13/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(tidyverse)
library(RCurl)
```

# Chess ELO Table - Clean and Extract

_I collaborated with Neil Shah on this project for some of the regex statements as well as general cleaning strategy_

The crosstable information is stored in a `.txt` file and will be to scrubed of all formatting and presented in a data frame of the following columns

Name, State, Points Scored, Prior Rank, Average Opponent Ranking

## General Approach

First I am going to develop the regex expressions necessary to pull the desired information from the `.txt` file. Once I get the general information, I will use the data frame features of R to further clean and prepare the data in pursuit of the final goal. 


### Initial Formatting Clean

```{r}
data<- readLines("tournamentinfo.txt")
data<- data[data != strrep("-",89)]
data<-data[3:130]
data<-unlist(lapply(data, function(x) x[!x %in% ""]))
data[1:10]
```


## Regex 

Using regex to create vectors for data fields that will go into the data frame. 

```{r}
uscf_regex<-"[0-9]{8}"
uscf_id<-unlist(str_extract_all(data, uscf_regex))
uscf_id
```

```{r}
points_regex<-"[:digit:]\\.[:digit:]"
points<-unlist(str_extract_all(data, points_regex))
points
```


```{r}
state_regex<-"\\s\\s[A-Z]{2}"
states<-unlist(str_extract_all(data, state_regex))
states
```

I wanted to be sure to get everyones full name. Many players had multiple names and I know how annoying it is to see everyone with only first and last name have there names displayed but not the person with three (or more). For example, the player Dinh Dang Bui; Bui is likely the last name (it's a very commmon Vietnamese last name) and Dinh Dang would be the first name. I want to capture this player's full name

```{r}
name_regex<-"[0-9] \\| [:alpha:]+\\s[:alpha:]+\\s?([:alpha:]+\\s)[:alpha:]*"
name<- unlist(str_extract_all(data, name_regex))
name<- str_remove_all(name, "[:digit:]\\s\\|")
name
```

```{r}
score_regex<-"R:\\s*[:digit:]{3,4}"
score<-unlist(str_extract_all(data, score_regex))
score<-str_remove_all(score, "R:\\s")
score
```

This regex should pull in the outcomes of each match in the form, for example, "|W  39|..." for all seven rounds. 

```{r}
games_regex<-"(\\|[WLDHUBX]\\s\\s.[:digit:]|\\|[HUBX]\\s\\s.[:blank:]){3,7}+"
games<-unlist(str_extract_all(data, games_regex))
games<- unlist(str_replace_all(games,"\\|", ","))
games<- strsplit(games, ",")
for (i in 1:length(games)){
  games[[i]]<-games[[i]][2:length(games[[i]])]
}
```

I will further scrub the matches to the individual Win, Loss, Draw, etc and the opponent number. The following functions separate and organize those results. 

```{r}
make.game.outcome<- function(games_list, game_num){
  game_outcome<- rep(NA, 64)
  game_op<- rep(NA, 64)
  for (i in 1:length(games_list)){
    game_outcome[i]<-str_extract(games_list[[i]][game_num],
                                 "[:alpha:]{1}")
    game_op[i]<-str_extract(games_list[[i]][game_num],
                            "[0-9]{1,2}")
  }
  result<-list(game_outcome, game_op)
  return (result)
}
```

```{r}
make.outcome.opp.data<- function(game_list,game_num){
    game_i<- make.game.outcome(game_list, game_num)
    game_opp<-game_i[[2]]
    # Alternatively, the first element in this list stores the WLDHUBX game outcome
    outcome_opp<-cbind(game_opp)
  return(outcome_opp)
}
```

## Dataframe Creation

The following builds the dataframe and recasts some of the columns as integers or numerics.

```{r}
df<-data.frame(name, states, uscf_id, points, score, 
               make.outcome.opp.data(games,1),
               make.outcome.opp.data(games,2),
               make.outcome.opp.data(games,3),
               make.outcome.opp.data(games,4),
               make.outcome.opp.data(games,5),
               make.outcome.opp.data(games,6),
               make.outcome.opp.data(games,7)
)
factors<-c('name', 'states', 'points')
cols<- colnames(df)
cols<-cols[! cols %in% factors]
cols <- cols[!is.na(cols)]
df[,cols] <- apply(df[,cols], 2,
                    function(x) as.integer(as.character(x)))
df$points<-as.numeric(as.character(df$points))
```

Now for each row I need to replace the opponent number with that opponents pre-tournament ranking. 

```{r}
game_cols<- c('game_opp', 'game_opp.1', 'game_opp.2', 'game_opp.3',
              'game_opp.4', 'game_opp.5', 'game_opp.6')
make.opp.scores<- function(df,cols){
  for (j in cols){
    for (i in 1:nrow(df)){
      df[[j]][i]<-df$score[df[[j]][i]]
    }
  }
  return(df)
}
df<-make.opp.scores(df, game_cols)
```

Once we have the scores in place, we can calculate the average opponent score for each player. 

```{r}
make.average.score<- function(df, cols){
  for (i in 1:nrow(df)){
    df$opp_average[i]<-as.integer(sum(df[i,cols],na.rm=T) /
                                    sum(!is.na(df[i,cols])))
  }
  return(df)
}
df<-make.average.score(df, game_cols)
```

## Result

```{r}
df[ ,c('name', 'states','points','score', 'opp_average')]
```




